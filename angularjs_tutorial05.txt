tps://docs.angularjs.org/tutorial/step_05
$ git checkout -f step-5


//===
use Angular's $http service in our controller to make an HTTP request to your web server to fetch the data in the app/phones/phones.json file. 

//=== DI, Dependency Injection 
Angular injects these services for you where you need them.
Services are managed by Angular's DI subsystem. Dependency injection helps to make your web apps both well-structured (e.g., separate components for presentation, data, and control) and loosely coupled (dependencies between components are not resolved by the components themselves, but by the DI subsystem).



The $http service returns a promise object with a success method. We call this method to handle the asynchronous response and assign the phone data to the scope 

 Angular detected the json response and parsed it for us!

To use a service in Angular, you simply declare the names of the dependencies you need as arguments to the controller's constructor function, as follows:
phonecatApp.controller('PhoneListCtrl', function ($scope, $http) {...}
Angular's dependency injector provides services to your controller when the controller is being constructed. 


*** js minification break the $ ?
if you were to minify the JavaScript code for PhoneListCtrl controller, 
all of its function arguments would be minified as well, ]
and the dependency injector would not be able to identify services correctly.

--> strings will not get minified
There are two ways to provide these injection annotations:

Create a $inject property on the controller function which holds an array of strings. Each string in the array is the name of the service to inject for the corresponding parameter. In our example we would write:

function PhoneListCtrl($scope, $http) {...}
PhoneListCtrl.$inject = ['$scope', '$http'];
phonecatApp.controller('PhoneListCtrl', PhoneListCtrl);
Use an inline annotation where, instead of just providing the function, you provide an array. This array contains a list of the service names, followed by the function itself.

function PhoneListCtrl($scope, $http) {...}
phonecatApp.controller('PhoneListCtrl', ['$scope', '$http', PhoneListCtrl]);
Both of these methods work with any function that can be injected by Angular,





//=== $ Prefix Naming Convention, conflict with jQuery or not ???
The $ prefix is there to namespace Angular-provided services. 
To prevent collisions it's best to avoid naming your services and models anything that begins with a $.




some properties that begin with $$. These properties are considered private, and should not be accessed or modified.



 
//=== 
***  using dependency injection and our controller has dependencies, constructing the controller in our tests is a bit more complicated. 

*** mock http service,  _$httpBackend_ , mock/ fake/ imitate/ masquerade



Angular provides a mock $http service that we can use in unit tests. 
We configure "fake" responses to server requests by calling methods 
on a service called $httpBackend:


Note: Because we loaded Jasmine and angular-mocks.js in our test environment, 
we got two helper methods module and inject that we'll use to access and configure the injector.

...
beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
    $httpBackend = _$httpBackend_;
    $httpBackend.expectGET('phones/phones.json').
        respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

    scope = $rootScope.$new();
    ctrl = $controller('PhoneListCtrl', {$scope: scope});



//===
Use the $httpBackend.expectGET method to train the $httpBackend service to expect an incoming HTTP request and tell it what to respond with. 
Note that the responses are not returned until we call the $httpBackend.flush method.


it('should create "phones" model with 2 phones fetched from xhr', function() {
  expect(scope.phones).toBeUndefined();
  $httpBackend.flush();

  expect(scope.phones).toEqual([{name: 'Nexus S'},
                               {name: 'Motorola DROID'}]);
});




//===
cd app/js
notepad controllers.js

